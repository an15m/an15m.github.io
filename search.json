[{"title":"linux添加用户","url":"/2017/09/26/linux添加用户/","content":"<Excerpt in index | 首页摘要>\nlinux添加新用户\n<!-- more -->\n<The rest of contents | 余下全文>\n\n## 新建组(非必须)\n\n```bash\ngroupadd --gid 2000 groupname     #2000为组ID  要大于500\n```\n\n## 新建用户\n\n```bash\nuseradd username -g groupname -m -s /bin/bash\n```\n\n## 设置密码\n\n```bash\npasswd username\n```\n\n## 获取root权限\n修改`/etc/sudoers`文件：\n\n```bash\n#找到下面两行，然后新增最后一行\n## Allow root to run any commands anywhere\nroot ALL=(ALL:ALL) ALL\nusername ALL=(ALL:ALL) ALL\n```\n\n\n\n\n\n\n\n\n\n> 如果文章对你有帮助,请去我的博客留个言吧! [我的博客][1]\n\n[1]: http://an15m.tk\n","tags":["linux"],"categories":["linux"]},{"title":"linux server使用U盘","url":"/2017/09/26/linux-server使用U盘/","content":"<Excerpt in index | 首页摘要>\nlinux server中挂载、卸载U盘\n<!-- more -->\n<The rest of contents | 余下全文>\n\n## 挂载\n在插入U盘前先进到`/dev`目录下面`ls`一下\n插入U盘以后再`ls`一下，查看目录下面多了什么，一般是`sdb sdb4 sdc sdc4...`\n使用`sudo mount /dev/sdb4  /mnt/`进行挂载，之后进入`/mnt`目录就是U盘的目录\n\n## 卸载\n`sudo umount /dev/sdb4`然后拔掉U盘即可\n\n\n\n\n\n\n\n\n\n> 如果文章对你有帮助,请去我的博客留个言吧! [我的博客][1]\n\n[1]: http://an15m.tk\n","tags":["linux"],"categories":["linux"]},{"title":"Ubuntu设置静态IP","url":"/2017/09/26/Ubuntu设置静态IP/","content":"<Excerpt in index | 首页摘要>\nUbuntu设置静态IP并配置永久DNS\n<!-- more -->\n<The rest of contents | 余下全文>\n\n## 设置静态IP\n使用`ifconig`命令查看网卡，例如`eth0`\n打开`/etc/network/interfaces`修改内容如下：\n\n```bash\nauto lo\niface lo inet loopback  \n \nauto eth0 #对应ifconfig的结果\niface eth0 inet static\naddress 192.168.1.*** \nnetmask 255.255.255.0\ngateway 192.168.1.1   #根据自己实际情况\n```\n\n## 设置永久dns\n在`/etc/resolv.conf`中添加两行：\n\n```bash\nnameserver 114.114.114.114\nnameserver 8.8.8.8\n```\n\n在`/etc/resolvconf/resolv.conf.d/bash`中也添加两行：\n\n```bash\nnameserver 114.114.114.114\nnameserver 8.8.8.8\n```\n\n## 重启网络\n以下命令可选：\n\n```bash\nsudo /etc/init.d/networking restart\nsudo service networking restart\nsudo ifdown eth0; sudo ifup eth0 \n```\n如果上面的命令都失败的话，就只能重启系统了\n\n\n\n\n\n\n\n\n\n> 如果文章对你有帮助,请去我的博客留个言吧! [我的博客][1]\n\n[1]: http://an15m.tk\n","tags":["ubuntu"],"categories":["linux"]},{"title":"markdown语法","url":"/2017/09/10/markdown语法/","content":"<Excerpt in index | 首页摘要>\nmarkdown语法\n<!-- more -->\n<The rest of contents | 余下全文>\n\n## 兼容html\nmarkdown只包含html标签的一部分，对于没有被包含的html标签，可以直接在md中使用。但是html区块元素比如`<div>、<table>、<pre>、<p>`等标签，必须在前后加上空行与其他内容隔开，还要求他们的开始标签与结尾标签不能用制表符或空格来缩进。例如：\n\n```html\n这是一个普通段落。\n\n<table>\n  <tr>\n        <td>Foo</td>\n    </tr>\n</table>\n\n这是另一个普通段落。\n```\n请注意，在 HTML 区块标签间的 Markdown 格式语法将不会被处理。比如，你在 HTML 区块内使用 Markdown 样式的`*强调*`会没有效果。\n\nHTML 的区段（行内）标签如 `<span>、<cite>、<del>` 可以在 Markdown 的段落、列表或是标题里随意使用。依照个人习惯，甚至可以不用 Markdown 格式，而直接采用 HTML 标签来格式化。举例说明：如果比较喜欢 HTML 的 `<a>` 或 `<img>` 标签，可以直接使用这些标签，而不用 Markdown 提供的链接或是图像标签语法。\n\n和处在 HTML 区块标签间不同，Markdown 语法在 HTML 区段标签间是有效的。\n____\n## 特殊字符自动转换\n`<和&`字符markdown会根据需要选择是否转换成`&lt;和&amp;`\n至于#，只要不在行首就行，当然在代码区块中出现在行首也是没问题的\n____\n## 区块元素\n### 段落\n一个 Markdown 段落是由一个或多个连续的文本行组成，它的前后要有一个以上的空行（空行的定义是显示上看起来像是空的，便会被视为空行。比方说，若某一行只包含空格和制表符，则该行也会被视为空行）。普通段落不该用空格或制表符来缩进。\n### 换行\nmarkdown的段内换行是自动的（手动在特定位置按回车对markdown来说是没用的）\n但是你可以先按两个空格再回车，即可实现在任意位置换行（即产生`<br />`标签）\n### 标题\n\n```markdown\n#标题1\n\n等同于:\n\n标题1\n===\n```\n\n```markdown\n##标题2\n\n等同于:\n\n标题2\n---\n```\n### 区块引用 Blockquotes\n用\">\"实现\n可以嵌套,通过不同数量的\">\"\n引用内可以使用其他markdown语法\n### 列表\n无序列表以`-`或`+`或`*` + `空格`\n有序列表以`数字` + `.` + `空格`\n有序列表跟数字的顺序并没有什么关系...\n如果两个列表项目间用空行分开，则在输出html的时候markdown会将项目内容用`<p>`标签包起来\n列表项目内包含多个段落时，段落间用一个由4个空格或1个制表符的空行隔开\n如果列表项目里需要用到引用，则>必须缩进：\n\n```markdown\n*   A list item with a blockquote:\n\n    > This is a blockquote\n    > inside a list item.\n```\n如果放代码块的话，代码块就需要缩进两次\n### 代码区块\n用缩进4个空格或是1个制表符来实现\n另外GitHub Flavored Markdown请参看[GFM](https://guides.github.com/features/mastering-markdown/#GitHub-flavored-markdown)\n\n### 分割线\n一行中用三个 `*` 或 `-` 或 `_`\n____\n## 区段元素\n### 链接\n行内式：\n\n```markdown\nThis is [an example](http://example.com/ \"Title\") inline link.\n\n[This link](http://example.net/) has no title attribute.\n```\nTitle可写可不写\n如果是同主机资源，可以使用相对路径\n\n```markdown\nSee my [About](/about/ \"Title\") page for details.\n\nSee my [About](/about/) page for details.\n```\n参考式：\n\n```markdown\nThis is [an example][id] reference-style link.\n```\n接着，在文件的任意处，你可以把这个标记的链接内容定义出来：\n\n```markdown\n[id]: http://example.com/  \"Optional Title Here\"\n或\n[id]: http://example.com/  (Optional Title Here)\n或\n[id]: http://example.com/\n```\n你也可以把 title 属性放到下一行，也可以加一些缩进，若网址太长的话，这样会比较好看：\n\n```markdown\n[id]: http://example.com/\n    \"Optional Title Here\"\n```\n链接辨别标签可以有字母、数字、空白和标点符号，但是并不区分大小写\n隐式链接标记功能让你可以省略指定链接标记，如：\n\n```markdown\n[Google][]\n```\n然后定义链接内容：\n\n```markdown\n[Google]: http://google.com/\n```\n### 强调\nMarkdown 使用星号`*`和底线`_`作为标记强调字词的符号，被`*`或`_`包围的字词会被转成用 `<em>`标签包围，用两个`*`或 `_`包起来的话，则会被转成 `<strong>`，例如：\n\n```markdown\n*single asterisks*\n\n_single underscores_\n\n**double asterisks**\n\n__double underscores__\n```\n但是如果你的 * 和 _ 两边都有空白的话，它们就只会被当成普通的符号。\n如果要在文字前后直接插入普通的星号或底线，你可以用反斜线：\n\n```markdown\n\\*this text is surrounded by literal asterisks\\*\n```\n### 代码\n如果要标记一小段行内代码，你可以用*反引号*把它包起来，例如：\n\n```markdown\nUse the `printf()` function.\n```\n如果要在代码区段内插入反引号，你可以用多个反引号来开启和结束代码区段：\n\n```\n``There is a literal backtick (`) here.``\n```\n### 图片\n行内式：\n\n```markdown\n![Alt text](/path/to/img.jpg)\n\n![Alt text](/path/to/img.jpg \"Optional title\")\n```\n参考式：\n\n```markdown\n![Alt text][id]\n```\n「id」是图片参考的名称，图片参考的定义方式则和连结参考一样：\n\n```markdown\n[id]: url/to/image  \"Optional title attribute\"\n```\n到目前为止， Markdown 还没有办法指定图片的宽高，如果你需要的话，你可以使用普通的 `<img>` 标签。\n____\n## 其它\n### 自动链接\n网址自动链接：\n\n```markdown\n<http://example.com/>\n```\nmarkdown会转换为：\n\n```markdown\n<a href=\"http://example.com/\">http://example.com/</a>\n```\n邮箱自动链接：\n\n```markdown\n<address@example.com>\n```\nmakrdown会自动生成一个邮箱链接\n### 反斜杠\nMarkdown 可以利用反斜杠来插入一些在语法中有其它意义的符号，例如：如果你想要用星号加在文字旁边的方式来做出强调效果（但不用 `<em>` 标签），你可以在星号的前面加上反斜杠：\n\n```markdown\n\\*literal asterisks\\*\n```\nMarkdown 支持以下这些符号前面加上反斜杠来帮助插入普通的符号：\n\n```nohighlight\n\\  反斜线\n`  反引号\n-  星号\n_  底线\n{} 花括号\n[] 方括号\n() 括弧\n#  井字号\n*  加号\n+  减号\n.  英文句点\n!  惊叹号\n```\n\n\n\n\n\n\n\n\n\n\n> 如果文章对你有帮助,请去我的博客留个言吧! [我的博客][1]\n\n[1]: http://an15m.tk\n","tags":["markdown"],"categories":["markdown"]},{"title":"列出和删除iptables","url":"/2017/09/10/列出和删除iptables/","content":"<Excerpt in index | 首页摘要>\n列出和删除iptables\n<!-- more -->\n<The rest of contents | 余下全文>\n\n## 按规范列出iptables(按创建时的语句列出)\n列出所有激活的iptables rules\n```bash\n$ sudo iptables -S\n```\n\n## 列出特定的Chain\n\n```bash\n$ sudo iptables -S TCP\n$ sudo iptables -S INPUT\n...\n```\n\n## 以tables的形式列出\n```bash\n$ sudo iptables -L\n```\n\n## 按规范删除iptables\n在添加该iptables的命令中iptables后面表示添加的参数(例如`-I -A`)换成`-D`就行了\n```bash\n$ sudo iptables -A INPUT -m conntrack --ctstate INVALID -j DROP #添加\n$ sudo iptables -D INPUT -m conntrack --ctstate INVALID -j DROP #对应的删除\n```\n\n## 按chain和number来删除规则\n首先通过下面命令来列出规则：\n```bash\n$ sudo iptables -L --line-number\n```\n\n```\n# 示例输出\nChain INPUT (policy DROP)\nnum  target     prot opt source               destination\n1    ACCEPT     all  --  anywhere             anywhere             ctstate RELATED,ESTABLISHED\n2    ACCEPT     all  --  anywhere             anywhere\n3    DROP       all  --  anywhere             anywhere             ctstate INVALID\n...\n```\n然后我们就可以通过chain name和num来删除一条规则：\n```bash\n# 删除第三列target为DROP的那个规则\n$ sudo iptables -D INPUT 3  # INPUT 为第一行 Chain后面的名字，num为下面要删除的那个规则那一行首的num\n```\n\n## NOTES\n我在第一次尝试的时候首先通过以下命令添加了规则：\n```bash\nsudo iptables -t nat -I PREROUTING -p tcp --dport 443 -j REDIRECT --to-ports 8443\nsudo iptables -t nat -I OUTPUT -p tcp -o lo --dport 443 -j REDIRECT --to-ports 8443\n```\n然后就用列出规则的命令查看，结果怎么都出不来。\n原因如下：\n通过`-t nat`添加的规则，是添加到了一个叫nat的table中。而不用-t参数的时候，系统有个默认的叫做filter的table，所有不加-t参数的命令都是在操作filter这个table。\n那么到底怎么才能操作nat这个table呢？很简单，只要在上面所有命令中iptables的后面也加上一个`-t nat`就可以了。比如要列出规则：\n```bash\n$ sudo iptables -t nat -L\n```\n\n\n\n\n\n\n\n\n\n\n> 如果文章对你有帮助,请去我的博客留个言吧! [我的博客][1]\n\n[1]: http://an15m.tk\n","tags":["iptables"],"categories":["linux"]},{"title":"linux本地端口映射","url":"/2017/09/10/linux本地端口映射/","content":"<Excerpt in index | 首页摘要>\n将linux服务器的一个端口映射到本地的另一个端口\n<!-- more -->\n<The rest of contents | 余下全文>\n\n\n## 使用iptables建立规则\n例：将3722端口映射到22端口\n```bash\n$ sudo iptables -t nat -I PREROUTING -p tcp --dport 3722 -j REDIRECT --to-ports 22\n$ sudo iptables -t nat -I OUTPUT -p tcp -o lo --dport 3722 -j REDIRECT --to-ports 22\n```\n\n## 永久生效\n1. 安装iptables-persistent\n    ```bash\n    sudo apt-get install iptables-persistent\n    ```\n2. 然后，可以通过下面的命令来保存或重新加载iptables rules\n    ```bash\n    sudo /etc/init.d/iptables-persistent save\n    sudo /etc/init.d/iptables-persistent reload\n    ```\n3. 对Ubuntu 16.04 Server上面的两个命令好像不好使，用下面两个命令代替：\n    ```bash\n    sudo netfilter-persistent save\n    sudo netfilter-persistent reload\n    ```\n\n\n\n\n\n\n\n\n\n\n> 如果文章对你有帮助,请去我的博客留个言吧! [我的博客][1]\n\n[1]: http://an15m.tk\n","tags":["iptables"],"categories":["linux"]},{"title":"JAVA编程思想第四版第五章","url":"/2017/09/07/thinking-in-java-v4-5/","content":"<Excerpt in index | 首页摘要>\n第五章 初始化与清理\n<!-- more -->\n<The rest of contents | 余下全文>\n\n## 用构造器确保初始化\n- 构造器必须与类同名，并且没有返回值，这与返回值为空(void)不同。\n- 在java中，“创建”和“初始化”是捆绑在一起的，两者不能分离。\n\n## 方法重载\n- 参数顺序的不同，也可以区别两个方法。\n\n## this关键字\n- `this`关键字的含义：调用这个方法的对象的引用。\n- 在一个类中，调用类中的某个方法，需要在前面加`this`关键字，但是在方法内部调用同一个类中的另一个方法，不需要写`this`。也就是说只有在类主体中调用类中的方法，才需要用到`this`关键字。\n\n## 清理：最终处理和垃圾回收\n- java的垃圾回收器只能释放由`new`分配的内存。\n- 对象可能不被回收：如果java虚拟机(JVM)并未面临内存耗尽的情形，它是不会浪费实践去执行垃圾回收以回复内存的。\n- java允许在类中定义个`finalize()`方法，当垃圾回收器将要释放无用对象的内存时，先调用该对象的`finalize()`方法。如果在程序终止之前垃圾回收器始终没有执行垃圾回收操作，那么垃圾回收器将始终不会调用无用对象的`finalize()`方法。但是，很重要，垃圾回收什么时候发生，会不会发生，没有人可以预知，就算是使用了`System.gc()`或`Runtime.gc()`方法，垃圾回收也不一定会发生。所以，慎用！\n\n## 初始化顺序\n1. 在类的内部，变量定义的先后顺序决定了初始化的顺序。即使变量定义散步于方法定义之间，他们仍旧会在任何方法(包括构造器)被调用之前就得到初始化。\n2. 静态初始化只有在必要时刻才初始化。\n3. 初始化的顺序是先静态对象(如果它们尚未初始化)，然后是“非静态”对象。\n4. 构造器可以看成是静态方法。\n5. 显式的静态初始化：通过“静态块”，例如：\n    ```java\n    static int i;\n    static int j;\n    static {\n        i = 1;\n        j = 2;\n    }\n    ```\n  同样的，显式的静态初始化代码，也只有在必须的时候才会执行。\n\n## 非静态实例初始化\njava中也有被称为实例初始化的类似语法，用来初始化每一个对象的非静态变量。例如：\n```java\npublic class Init(){\n    int i;\n    int j;\n    {\n        i = 1;\n        j = 2;\n    }\n}\n```\n\n## 数组初始化\n1. `int[] a = {1,2,3}`，这种数组初始化方式等价于使用`new`。\n2. 数组之间赋值，例如：\n    ```java\n    int[] a1 = {1,2,3};\n    int[] a2 = a1;\n    ```\n  真正复制的其实是一个引用，也就是说，当改变`a2`时，`a1`也会跟着变。\n3. 基本类型的数组在创建后会被自动初始化为默认值。\n4. 非基本类型的数组必须手动初始化。\n5. 可变参数列表，例如：\n    ```java\n    void f(int a, String... b){\n        //codes...\n    }\n    ```\n  上例中，可以传入0 ~ N个字符串。另外，可变参数必须方法参数列表的最后。\n\n## 枚举类型enum\n1. 枚举类型的实例是常量，因此按照命名习惯它们都用大写字母表示(如果一个名字中有多个单词，用下划线将它们隔开)。例如：\n    ```java\n    public enum Directions{\n        EAST , WEST , SOUTH , NORTH , NORTH_EAST , SOUTH_WEST\n    }\n    ```\n2. 为了使用`enum`，需要创建一个该类型的引用，并将其赋值给某个实例：\n    ```java\n    Directions east = Directions.EAST;\n    System.out.println(east);\n    ```\n3. 在你创建`enum`时，编译器会自动添加一些有用的特性。例如，自动创建`toString()`方法来转换成字符串，`ordinal()`方法来表示某个特定`enum`常量的声明顺序、`static values()`方法用来按照`enum`常量的声明顺序，产生由这些常量值构成的数组：\n    ```java\n    for(Directions d : Directions.values()){\n      System.out.println(d + \", ordinal \" + d.ordinal());\n    }\n    ```\n4. `enum`是一个类，并且拥有自己的方法。\n5. `enum`与`switch`的完美配合：\n    ```java\n    Directions direction;\n    switch(direction){\n        case EAST: System.out.println(\"The direction of east.\");break;\n        case WEST: System.out.println(\"The direction of west.\");break;\n        case NORTH: System.out.println(\"The direction of north.\");break;\n        case SOUTH: System.out.println(\"The direction of south.\");break;\n        case NORTH_EAST: System.out.println(\"The direction of north-east.\");break;\n        case SOUTH_WEST: System.out.println(\"The direction of south-west.\");break;\n        default: System.out.println(\"Other directions.\");\n    }\n    ```\n  其实`default`不是必须的，因为你知道有多少种可能性，不可能有未知的可能性。\n\n\n\n\n\n\n\n\n\n\n> 如果文章对你有帮助,请去我的博客留个言吧! [我的博客][1]\n\n[1]: http://an15m.tk\n","tags":["java"],"categories":["JAVA编程思想v4"]},{"title":"JAVA编程思想第四版第四章","url":"/2017/09/07/thinking-in-java-v4-4/","content":"<Excerpt in index | 首页摘要>\n第四章  执行控制流程\n<!-- more -->\n<The rest of contents | 余下全文>\n\n## Foreach语法\n`Foreach`可以用于任何`Iterable`对象。\n```java\nfloat[] f = new float[]{1.1f,2.1f,3.2f};\nfor (float x : f) {\n    System.out.println(x);\n}\n```\n\n## 臭名昭著的goto\n1. java不支持`goto`语句，但仍可以进行类似的跳转，但比起典型的`goto`有了很多限制。另外，`goto`仍然是java中的一个保留字。\n2. 标签的使用：标签是后面跟有冒号的标识符，就像`label1:`这样。java中标签要写在迭代语句之前，中间最好不要有任何其他语句。假如有以下代码：\n    ```java\n    label1:\n    outer-iteration{\n        inter-iteration{\n            //...\n            break; //(1)\n            //...\n            continue; //(2)\n            //...\n            continue label1; //(3)\n            //...\n            break label1; //(4)\n        }\n    }\n    ```\n    在(1)中，`break`中断内部迭代，回到外部迭代。  \n    在(2)中，`continue`是执行点移回内部迭代的起始处。  \n    在(3)中，`continue label1`同时中断内部迭代以及外部迭代，直接转到`label1`处；随后，它实际上是继续迭代过程，但却从外部迭代开始。  \n    在(4)中，`break label1`也会中断所有迭代，并回到`label1`处，但并不重新进入迭代，它实际上是完全终止了两个迭代。\n\n## switch\nswitch中的选择因子必须是`int`或`char`那样的整数值(java7以后也可以使用字符串)。\n\n\n\n\n\n\n\n\n\n\n> 如果文章对你有帮助,请去我的博客留个言吧! [我的博客][1]\n\n[1]: http://an15m.tk\n","tags":["java"],"categories":["JAVA编程思想v4"]},{"title":"JAVA编程思想第四版第三章","url":"/2017/09/07/thinking-in-java-v4-3/","content":"<Excerpt in index | 首页摘要>\n第三章 操作符\n<!-- more -->\n<The rest of contents | 余下全文>\n\n## 赋值\n\n- 基本类型的赋值：基本类型存储了实际的值，而非指向一个对象的引用，所以在其赋值的时候，是直接将一个地方的内容复制到另一个地方。\n- 对象的“赋值”：对一个对象进行操作时，我们真正操作的是对象的引用。所以倘若“将一个对象赋值给另一个对象”，实际是将“引用”从一个地方复制到了另一个地方。这意味着假若对对象使用`c=d`，那么c和d都指向原本只有d指向的那个对象。也就是说，当“c指向的对象发送变化时”，“d指向的对象”也会跟着发生变化，而原来c所指向的那个对象，现在没有任何标识符指向它，所以它“丢失了”，“垃圾回收器”会自动将它清理，而c实际上成了d的一个“别名”，这种现象称为“别名现象”。而在基本类型的赋值中，c的变化是不影响d的。\n- 由于“别名现象”的存在：，假如我们将一个对象以参数的形式传递给一个方法，在方法内部修改对象会影响到方法外部的对象。\n\n## 算术操作符\n\n- 整数除法会直接去掉小数位，而不是四舍五入。\n\n## 关系操作符\n\n- `==`与`!=`：当这两个关系操作符作用与对象时，比较的是两个对象的“引用”是否相同，也就是这两个对象是不是同一个对象。而要比较两个对象的实际内容是不是相同的话，可以使用所有对象都适用的`equals()`方法。但是若比较的两个对象中有我们自己创建的类，那么我们需要在我们写的类中覆盖`equals()`方法，因为我们写的类中的默认`equals()`方法比较的还是引用。\n\n## 直接常量\n\n1. 直接常量一般要在其后面加上后缀字符以标志它的类型：\n\t```\n\t后缀：\n\t    L或l：long\n\t    F或f：float\n\t    D或d：double\n\t前缀：\n\t    0x或0X：十六进制，十六进制数使用于所有整数数据类型(可以赋值给所有整数类型)\n\t    0：八进制\n\t```\n\t在使用十六进制和八进制的时候，可以使用`Integer`和`Long`类的静态方法`toBinaryString()`将结果以二进制形式显示出来。\n\n\n## 按位操作符\n\n- `&`：与；`|`：或；`~`：非；`^`：异或\n- 布尔值可以执行按位“与”、“或”和“异或”操作，不能执行按位“非”操作。\n- 移位表达式中，不能使用布尔运算。\n\n## 移位操作符\n\n- `<<`：左移操作符。能按照操作符右侧指定的位数将操作符左侧的操作数向左移动(在低位补0)。\n- `>>`：“有符号”右移操作符。按照操作符右侧指定的位数将操作符左侧的操作数向右移动。“有符号”右移操作符使用“符号扩展”：若符号为正，则在高位插入0；若符号为负，则在高位插入1.\n- `>>>`：“无符号”右移操作符。它使用“零扩展”：无论正负，都在高位插入0。\n\n## 字符串操作符 + 或 +=\n\n- java中不支持操作符的重载\n\n##  类型转换操作符\n\n- java允许我们把任何基本数据类型转换成别的基本数据类型，但布尔型除外，布尔型不允许进行任何类型转换。\n- “类”数据类型，不允许进行类型转换。为了将类转换成另一种，必须采用特殊的方法。\n- 将`float`或`double`转型为整数类型时，总是对该数字执行截尾。如果要得到舍入的结果，就要使用`java.lang.Math`中的`round()`方法。\n- 对比`int`小的类型(`byte`、`char`或`short`)执行算术运算或者按位运行，那么在运算之前，这些值会自动转换成`int`。这样，最终的结果也是`int`类型。\n- java对两个`int`运算结果溢出不会报错也没有警告信息。\n\n\n\n\n\n\n\n\n\n\n> 如果文章对你有帮助,请去我的博客留个言吧! [我的博客][1]\n\n[1]: http://an15m.tk\n","tags":["java"],"categories":["JAVA编程思想v4"]},{"title":"JAVA编程思想第四版第二章","url":"/2017/09/07/thinking-in-java-v4-2/","content":"<Excerpt in index | 首页摘要>\n第二章 一切都是对象\n<!-- more -->\n<The rest of contents | 余下全文>\n\n1. 数据存储的地方：按快慢：寄存器>堆栈>堆>常量存储>非RAM存储\n    1. 常量存储：存放在程序代码内部\n    2. 非RAM存储：存放在程序之外，比如 *流对象* 和 *持久化对象*\n2. 基本类型和非基本类型的区别\n    <input type=\"hidden\" value=\"Just for something ! You can ignore it.\">\n    1. 非基本类型使用`new`关键字来初始化，存储于堆中，操作非基本类型使用的实际上是对象的一个“引用”，而非对象本身。\n    2. 基本类型的创建不用`new`关键字，而是创建一个非引用的“自动”变量，直接存储“值”，存储于堆栈中，比存储于堆中更加高效。另外，java基本类型所占存储空间的大小不随机器硬件架构的变化而变化。\n    3. java中存在基本类型的包装类型，比如int的包装类型为Integer类型，可以使用`new Integer(1);`或`Integer integer = 3;`在堆中创建一个非基本类型，来表示对应的基本类型。\n3. java中不允许在C和C++里将一个较大作用域的变量“隐藏”起来的做法，以下代码是错误的：\n    ```java\n    {\n        int x = 12;\n        {\n            int x = 9;\n        }\n    }\n    ```\n4. java对象不具备和基本类型一样的生命周期。当用`new`创建一个java对象时，它可以存活于作用域之外。例如以下代码：\n    ```java\n    {\n        String s = new String(\"a string\");\n    }//作用域终点\n    ```\n    引用s在作用域终点就消失了，然而，s指向的String对象仍继续占据内存空间。\n5. 当变量作为 *类的成员* 时，java会自动用默认值对其进行初始化；但当变量作为 *局部变量* (并非某个类的字段)时，java不会对其进行自动初始化。\n6. `static`关键字\njava中的 *成员* 与 *方法* 都是与类绑定的，只有通过`new`创建那个类的对象，该类的 *成员* 和 *方法* 才可以被外界调用。\n有两种情形是用上述方法无法满足的。一是情况是想给某特定域分配单一存储空间，而不去考虑究竟要创建多少对象，甚至根本就不创建任何对象。另一种情况是希望某个方法不与包换它的类的任何对象关联在一起，也就是说，即使没有创建对象，也可以调用这个方法。\n`static`可以满足这两方面的需求。当声明一个事物是`static`时，就意味着这个域或者方法不会与包含它的那个类的任何对象事例关联在一起。所以，即使从未创建某个类的任何对象，也可以调用其`static`方法或访问其`static`域。假设有以下代码：\n    ```java\n    class StaticTest{\n      static int i = 47;\n    }\n    ```\n    现在，即使你创建了两个`StaticTest`对象，`StaticTest.i`也只有一份存储空间，这两个对象共享同一个`i`。如果继续写：\n    ```java\n    StaticTest st1 = new StaticTest();\n    StaticTest st2 = new StaticTest();\n    ```\n    在这里，`st1.i`和`st2.i`指向同一存储空间，因此他们具有相同的值47。\n引用`static`变量有两种方法。一是通过一个对象去定位它，如`st1.i`；也可以通过类名直接引用，如`StaticTest.i`,而这对于非静态成员则不行。\n7. 注释文档\n如果代码与文档是分离的，那么在每次修改代码时，都需要修改相应的文档。javadoc允许你将代码与文档写在一个文件内，然后由javadoc去提取注释。javadoc的输出是一个HTML文档。此外，如果想对javadoc处理过的信息执行特殊的操作，那么可以通过编写你自己的被称为“doclets”的javadoc处理器来实现。下面介绍javadoc的语法：\n    - 所有javadoc命令都只能在`/**`注释中出现，结束和通常一样使用`*/`。\n    - 使用javadoc的方式主要有两种：嵌入HTML或使用“文档标签”。 *独立文档标签* 是一些以“@”字符开头的命令，要置于注释行的最前面。 *行内文档标签* (在花括号内)可以出现在javadoc注释中的任何地方，也是以“@”开头。\n    - 共有三种类型的注释文档，分别对应与注释位置后面的三种元素：类、域和方法。例：\n        ```java\n        /** 类注释 */\n        public class Documentation{\n          /** 域注释 */\n          public int i;\n          /** 方法注释 */\n          public void f(){}\n        }\n        ```\n    - javadoc只能为`public`和`protected`成员进行文档注释。`private`和包内可访问成员的注释会被忽略掉(可以用`-private`参数将`private`成员的注释也包括在内)\n    - 嵌入式HTML：javadoc支持利用HTML对文档进行格式化，例如：\n        ```java\n        /**\n        * <pre>\n        * System.out..println(new Date());\n        * </pre>\n        */\n        ```\n        不要在嵌入式HTML中使用标题标签，例如`<h1>`或`<hr>`，因为javadoc会插入自己的标题，而你的标题可能同它们发生冲突。\n    - 注意，在文档注释中，位于每一行开头的`*`和前导空格都会被javadoc丢弃。\n    - 一些标签示例：\n        - `@see` ：引用其他类。`@see`标签允许用户引用其他类的文档。javadoc会在其生成的文件中，通过`@see`标签链接到其他文档。格式如下：\n            ```java\n            @see classname\n            @see fully-qualified-classname    //无歧义类名\n            @see fully-qualified-classname#method-name\n            ```\n            上述每种格式都会在生成的文档中加入一个具有超链接的“See Also”(参见)条目。但是javadoc不会检查你所提供的超链接是否有效。\n        - `{@link package.class#member label}`：该标签与`@see`标签极其相似，只是它用与行内，并且是用“label”作为超链接文本而不用“See Also”。\n        - `{@docRoot}`：该标签产生到文档根目录的相对路径，用于文档树页面的显式超链接。\n        - `{@inheritDoc}`：该标签从当前这个类的最直接的基类中继承相关文档到当前的文档注释中。\n        - `@version`：格式如下：\n            ```java\n            @version version-information\n            ```\n            其中，“version-information”可以是任何你认为适合包含在版本说明中的重要信息。javadoc通过`-version`参数来获取版本信息。\n        - `@author`：格式如下：\n            ```java\n            @author author-information\n            ```\n            其中，“author-information”可以包含作者姓名、电子邮件或其他适宜的信息。javadoc通过`-author`获取作者信息。使用多个标签列出所有作者是，他们必须连续放置。\n        - `@since`：最早使用该方法、类或接口的版本\n        - `@param`：格式如下：\n            ```java\n            @param parammeter-name description\n            ```\n            “parammeter-name”为参数名，“description”为说明，可以给每个参数写一个。\n        - `@return`：格式如下：\n            ```java\n            @return description\n            ```\n            “description”用来描述返回值的信息。\n        - `@throws`：格式如下：\n            ```java\n            @throws fully-qualified-class-name description\n            ```\n            “fully-qualified-class-name”为一个异常类的无歧义名字。对所有可能抛出的异常类都要进行说明。\n        - `@deprecated`：该标签用于指出一些旧特性已由改进的新特性取代。Java SE5中，该标签已被`@Deprecated`标签取代。\n8. 编码风格：\n    - 类名首字母要大写\n    - 如果类名由几个单词构成，那么把它们并在一起(不要用下划线来分隔名字)，其中每个内部单词的首字母都采用大写形式。这种风格有时称作“驼峰风格”。几乎其他所有内容——方法、字段(成员变量)以及对象引用名称等，都用这种格式，不一样的只是标识符的第一个字母采用小写。\n\n\n\n\n\n\n\n\n\n\n> 如果文章对你有帮助,请去我的博客留个言吧! [我的博客][1]\n\n[1]: http://an15m.tk\n","tags":["java"],"categories":["JAVA编程思想v4"]},{"title":"JAVA编程思想第四版第一章","url":"/2017/09/07/thinking-in-java-v4-1/","content":"<Excerpt in index | 首页摘要>\n第一章 对象导论\n<!-- more -->\n<The rest of contents | 余下全文>\n\n1. `private`关键字：除类型创建者和类型的内部方法之外的任何人都不能访问。  \n   `protected`关键字：与`private`相当，差别在与继承的类可以访问`protected`成员。\n\n\n\n\n\n\n\n\n> 如果文章对你有帮助,请去我的博客留个言吧! [我的博客][1]\n\n[1]: http://an15m.tk\n","tags":["java"],"categories":["java编程思想v4"]},{"title":"fsat git","url":"/2017/08/30/fsat-git/","content":"<Excerpt in index | 首页摘要>\ngit clone慢的解决方法\n<!-- more -->\n<The rest of contents | 余下全文>\n- 首先你要有一个代理，推荐[shadowsocks](https://github.com/shadowsocks)\n\n## 为http和https协议设置socks5代理\n```bash\ngit config --global http.proxy 'socks5://<your_proxy_host>:<your_proxy_port>'\ngit config --global https.proxy 'socks5://<your_proxy_host>:<your_proxy_port>'\n```\n\n## 为git协议设置socks5代理\n\n以下格式使用的是`git`协议\n```bash\ngit clone git://github.com/git/git.git\n```\n\n首先创建一个文件`git-proxy`，写入以下内容：\n```bash\n#!/bin/bash\nnc -x <your_proxy_host>:<your_proxy_port> $1 $2\n```\n这里的`nc`是`netcat openbsd`而不是`netcat traditional`。\n给文件添加可执行权限`sudo chmod +x git-proxy`。\n\n将`git-proxy`文件所在文件夹加入环境变量`$PATH`（记得刷新环境变量）。\n\n配置`core.gitProxy`：\n```bash\ngit config --global --add core.gitProxy git-proxy\n```\n\n## 为ssh协议设置socck5代理\n\n以下格式使用的是`ssh`协议：\n```bash\ngit clone git@github.com:git/git.git\n```\n\n在配置之前首先运行以下命令确保你能`ssh`到你想连接的网站。例如`github`：\n```bash\nssh -vT git@github.com\n```\n出现以下回应说明成功：\n```nohighlight\nHi your_username! You've successfully authenticated, but GitHub does not provide shell access.\n```\n\n以下方法不一定每个人都能用，取决于你的代理服务商有没有提供相关功能：\n修改 `~/.ssh/config` 加入如下内容：\n全局代理：\n```bash\nProxyCommand nc -X 5 -x <your_proxy_host>:<your_proxy_port> %h %p\n```\n特定域名进行代理：\n```bash\nHost 域名\nProxyCommand nc -X 5 -x <your_proxy_host>:<your_proxy_port> %h %p\n\nHost github.com\nProxyCommand nc -X 5 -x <your_proxy_host>:<your_proxy_port> %h %p\n```\n如果`git clone git@github:git/git.git`长时间无反应，最后报以下错误：\n```nohighlight\nssh_exchange_identification: Connection closed by remote host\nfatal: Could not read from remote repository.\n\nPlease make sure you have the correct access rights\nand the repository exists.\n```\n说明代理服务商不支持相关功能。\n\n\n\n\n\n\n\n\n\n\n\n> 如果文章对你有帮助,请去我的博客留个言吧! [我的博客][1]\n\n[1]: http://an15m.tk\n","tags":["git"],"categories":["git"]},{"title":"git config命令","url":"/2017/08/30/git-config/","content":"<Excerpt in index | 首页摘要>\ngit config命令相关知识\n<!-- more -->\n<The rest of contents | 余下全文>\n\n## 配置目录\n### git配置目录分三级\n- 仓库级，通过`--local`配置，在当前仓库下`.git/config`\n- 全局级，通过`--global`配置，在用户目录下`~/.gitconfig`\n- 系统级，通过`--system`配置，在`/etc/gitconfig`中\n- 配置文件的权重是`仓库>全局>系统`\n\n## 一些配置详解\n- `core.gitProxy`：当使用Git协议抓取时（作为命令主机端口？）执行的“代理命令”，而不是直接建立连接。如果变量值使用“COMMAND FOR DOMAIN”的格式，则该命令仅适用于以指定的域字符串结尾的主机名。该变量可以多次设置，并按照给定的顺序进行匹配; 以第一次匹配到的为准。\n这个配置可以被`GIT_PROXY_COMMAND`环境变量覆盖（它始终普遍应用）。\n特殊字符串`none`可以用作代理命令来指定给定域模式不使用任何代理。 这有助于在为外部域使用通用代理的同时从代理使用中排除防火墙内的服务器。\n- `http.sslVerify `：是否在获取或推送HTTPS时验证SSL证书。 可以被`GIT_SSL_NO_VERIY`环境变量覆盖。\n- `http.sslCert`：获取或推送HTTPS时包含SSL证书的文件。 可以被`GIT_SSL_CERT`环境变量覆盖。\n- `http.sslKey`：获取或推送HTTPS时包含SSL私钥的文件。 可以被`GIT_SSL_KEY`环境变量覆盖。\n\n\n\n\n> 如果文章对你有帮助,请去我的博客留个言吧! [我的博客][1]\n\n[1]: http://an15m.tk\n","tags":["git"],"categories":["git"]}]