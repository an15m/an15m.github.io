[{"title":"thinking in java v4 5","url":"/2017/09/07/thinking-in-java-v4-5/","content":"<Excerpt in index | 首页摘要>\n\n<!-- more -->\n<The rest of contents | 余下全文>\n\n\n\n\n\n\n\n\n\n\n\n> 如果文章对你有帮助,请去我的博客留个言吧! [我的博客][1]\n\n[1]: http://an15m.tk\n"},{"title":"thinking in java v4 4","url":"/2017/09/07/thinking-in-java-v4-4/","content":"<Excerpt in index | 首页摘要>\n\n<!-- more -->\n<The rest of contents | 余下全文>\n\n\n\n\n\n\n\n\n\n\n\n> 如果文章对你有帮助,请去我的博客留个言吧! [我的博客][1]\n\n[1]: http://an15m.tk\n"},{"title":"JAVA编程思想第四版第三章","url":"/2017/09/07/thinking-in-java-v4-3/","content":"<Excerpt in index | 首页摘要>\n第三章 操作符\n<!-- more -->\n<The rest of contents | 余下全文>\n\n## 赋值\n\n- 基本类型的赋值：基本类型存储了实际的值，而非指向一个对象的引用，所以在其赋值的时候，是直接将一个地方的内容复制到另一个地方。\n- 对象的“赋值”：对一个对象进行操作时，我们真正操作的是对象的引用。所以倘若“将一个对象赋值给另一个对象”，实际是将“引用”从一个地方复制到了另一个地方。这意味着假若对对象使用`c=d`，那么c和d都指向原本只有d指向的那个对象。也就是说，当“c指向的对象发送变化时”，“d指向的对象”也会跟着发生变化，而原来c所指向的那个对象，现在没有任何标识符指向它，所以它“丢失了”，“垃圾回收器”会自动将它清理，而c实际上成了d的一个“别名”，这种现象称为“别名现象”。而在基本类型的赋值中，c的变化是不影响d的。\n- 由于“别名现象”的存在：，假如我们将一个对象以参数的形式传递给一个方法，在方法内部修改对象会影响到方法外部的对象。\n\n## 算术操作符\n\n- 整数除法会直接去掉小数位，而不是四舍五入。\n\n## 关系操作符\n\n- `==`与`!=`：当这两个关系操作符作用与对象时，比较的是两个对象的“引用”是否相同，也就是这两个对象是不是同一个对象。而要比较两个对象的实际内容是不是相同的话，可以使用所有对象都适用的`equals()`方法。但是若比较的两个对象中有我们自己创建的类，那么我们需要在我们写的类中覆盖`equals()`方法，因为我们写的类中的默认`equals()`方法比较的还是引用。\n\n## 直接常量\n\n- 直接常量一般要在其后面加上后缀字符以标志它的类型：\n\n    ```nohighlight\n    后缀：\n        L或l：long\n        F或f：float\n        D或d：double\n    前缀：\n        0x或0X：十六进制，十六进制数使用于所有整数数据类型(可以赋值给所有整数类型)\n        0：八进制\n    ```\n    在使用十六进制和八进制的时候，可以使用`Integer`和`Long`类的静态方法`toBinaryString()`将结果以二进制形式显示出来。\n\n## 按位操作符\n\n- `&`：与；`|`：或；`~`：非；`^`：异或\n- 布尔值可以执行按位“与”、“或”和“异或”操作，不能执行按位“非”操作。\n- 移位表达式中，不能使用布尔运算。\n\n## 移位操作符\n\n- `<<`：左移操作符。能按照操作符右侧指定的位数将操作符左侧的操作数向左移动(在低位补0)。\n- `>>`：“有符号”右移操作符。按照操作符右侧指定的位数将操作符左侧的操作数向右移动。“有符号”右移操作符使用“符号扩展”：若符号为正，则在高位插入0；若符号为负，则在高位插入1.\n- `>>>`：“无符号”右移操作符。它使用“零扩展”：无论正负，都在高位插入0。\n\n## 字符串操作符 + 或 +=\n\n- java中不支持操作符的重载\n\n##  类型转换操作符\n\n- java允许我们把任何基本数据类型转换成别的基本数据类型，但布尔型除外，布尔型不允许进行任何类型转换。\n- “类”数据类型，不允许进行类型转换。为了将类转换成另一种，必须采用特殊的方法。\n- 将`float`或`double`转型为整数类型时，总是对该数字执行截尾。如果要得到舍入的结果，就要使用`java.lang.Math`中的`round()`方法。\n- 对比`int`小的类型(`byte`、`char`或`short`)执行算术运算或者按位运行，那么在运算之前，这些值会自动转换成`int`。这样，最终的结果也是`int`类型。\n- java对两个`int`运算结果溢出不会报错也没有警告信息。\n\n\n\n\n\n\n\n\n\n\n> 如果文章对你有帮助,请去我的博客留个言吧! [我的博客][1]\n\n[1]: http://an15m.tk\n","tags":["java"],"categories":["JAVA编程思想v4"]},{"title":"JAVA编程思想第四版第二章","url":"/2017/09/07/thinking-in-java-v4-2/","content":"<Excerpt in index | 首页摘要>\n第二章 一切都是对象\n<!-- more -->\n<The rest of contents | 余下全文>\n\n1. 数据存储的地方：按快慢：寄存器>堆栈>堆>常量存储>非RAM存储\n    1. 常量存储：存放在程序代码内部\n    2. 非RAM存储：存放在程序之外，比如 *流对象* 和 *持久化对象*\n2. 基本类型和非基本类型的区别\n    <input type=\"hidden\" value=\"Just for something ! You can ignore it.\">\n    1. 非基本类型使用`new`关键字来初始化，存储于堆中，操作非基本类型使用的实际上是对象的一个“引用”，而非对象本身。\n    2. 基本类型的创建不用`new`关键字，而是创建一个非引用的“自动”变量，直接存储“值”，存储于堆栈中，比存储于堆中更加高效。另外，java基本类型所占存储空间的大小不随机器硬件架构的变化而变化。\n    3. java中存在基本类型的包装类型，比如int的包装类型为Integer类型，可以使用`new Integer(1);`或`Integer integer = 3;`在堆中创建一个非基本类型，来表示对应的基本类型。\n3. java中不允许在C和C++里将一个较大作用域的变量“隐藏”起来的做法，以下代码是错误的：\n    ```java\n    {\n        int x = 12;\n        {\n            int x = 9;\n        }\n    }\n    ```\n4. java对象不具备和基本类型一样的生命周期。当用`new`创建一个java对象时，它可以存活于作用域之外。例如以下代码：\n    ```java\n    {\n        String s = new String(\"a string\");\n    }//作用域终点\n    ```\n    引用s在作用域终点就消失了，然而，s指向的String对象仍继续占据内存空间。\n5. 当变量作为 *类的成员* 时，java会自动用默认值对其进行初始化；但当变量作为 *局部变量* (并非某个类的字段)时，java不会对其进行自动初始化。\n6. `static`关键字\njava中的 *成员* 与 *方法* 都是与类绑定的，只有通过`new`创建那个类的对象，该类的 *成员* 和 *方法* 才可以被外界调用。\n有两种情形是用上述方法无法满足的。一是情况是想给某特定域分配单一存储空间，而不去考虑究竟要创建多少对象，甚至根本就不创建任何对象。另一种情况是希望某个方法不与包换它的类的任何对象关联在一起，也就是说，即使没有创建对象，也可以调用这个方法。\n`static`可以满足这两方面的需求。当声明一个事物是`static`时，就意味着这个域或者方法不会与包含它的那个类的任何对象事例关联在一起。所以，即使从未创建某个类的任何对象，也可以调用其`static`方法或访问其`static`域。假设有以下代码：\n    ```java\n    class StaticTest{\n      static int i = 47;\n    }\n    ```\n    现在，即使你创建了两个`StaticTest`对象，`StaticTest.i`也只有一份存储空间，这两个对象共享同一个`i`。如果继续写：\n    ```java\n    StaticTest st1 = new StaticTest();\n    StaticTest st2 = new StaticTest();\n    ```\n    在这里，`st1.i`和`st2.i`指向同一存储空间，因此他们具有相同的值47。\n引用`static`变量有两种方法。一是通过一个对象去定位它，如`st1.i`；也可以通过类名直接引用，如`StaticTest.i`,而这对于非静态成员则不行。\n7. 注释文档\n如果代码与文档是分离的，那么在每次修改代码时，都需要修改相应的文档。javadoc允许你将代码与文档写在一个文件内，然后由javadoc去提取注释。javadoc的输出是一个HTML文档。此外，如果想对javadoc处理过的信息执行特殊的操作，那么可以通过编写你自己的被称为“doclets”的javadoc处理器来实现。下面介绍javadoc的语法：\n    - 所有javadoc命令都只能在`/**`注释中出现，结束和通常一样使用`*/`。\n    - 使用javadoc的方式主要有两种：嵌入HTML或使用“文档标签”。 *独立文档标签* 是一些以“@”字符开头的命令，要置于注释行的最前面。 *行内文档标签* (在花括号内)可以出现在javadoc注释中的任何地方，也是以“@”开头。\n    - 共有三种类型的注释文档，分别对应与注释位置后面的三种元素：类、域和方法。例：\n        ```java\n        /** 类注释 */\n        public class Documentation{\n          /** 域注释 */\n          public int i;\n          /** 方法注释 */\n          public void f(){}\n        }\n        ```\n    - javadoc只能为`public`和`protected`成员进行文档注释。`private`和包内可访问成员的注释会被忽略掉(可以用`-private`参数将`private`成员的注释也包括在内)\n    - 嵌入式HTML：javadoc支持利用HTML对文档进行格式化，例如：\n        ```java\n        /**\n        * <pre>\n        * System.out..println(new Date());\n        * </pre>\n        */\n        ```\n        不要在嵌入式HTML中使用标题标签，例如`<h1>`或`<hr>`，因为javadoc会插入自己的标题，而你的标题可能同它们发生冲突。\n    - 注意，在文档注释中，位于每一行开头的`*`和前导空格都会被javadoc丢弃。\n    - 一些标签示例：\n        - `@see` ：引用其他类。`@see`标签允许用户引用其他类的文档。javadoc会在其生成的文件中，通过`@see`标签链接到其他文档。格式如下：\n            ```java\n            @see classname\n            @see fully-qualified-classname    //无歧义类名\n            @see fully-qualified-classname#method-name\n            ```\n            上述每种格式都会在生成的文档中加入一个具有超链接的“See Also”(参见)条目。但是javadoc不会检查你所提供的超链接是否有效。\n        - `{@link package.class#member label}`：该标签与`@see`标签极其相似，只是它用与行内，并且是用“label”作为超链接文本而不用“See Also”。\n        - `{@docRoot}`：该标签产生到文档根目录的相对路径，用于文档树页面的显式超链接。\n        - `{@inheritDoc}`：该标签从当前这个类的最直接的基类中继承相关文档到当前的文档注释中。\n        - `@version`：格式如下：\n            ```java\n            @version version-information\n            ```\n            其中，“version-information”可以是任何你认为适合包含在版本说明中的重要信息。javadoc通过`-version`参数来获取版本信息。\n        - `@author`：格式如下：\n            ```java\n            @author author-information\n            ```\n            其中，“author-information”可以包含作者姓名、电子邮件或其他适宜的信息。javadoc通过`-author`获取作者信息。使用多个标签列出所有作者是，他们必须连续放置。\n        - `@since`：最早使用该方法、类或接口的版本\n        - `@param`：格式如下：\n            ```java\n            @param parammeter-name description\n            ```\n            “parammeter-name”为参数名，“description”为说明，可以给每个参数写一个。\n        - `@return`：格式如下：\n            ```java\n            @return description\n            ```\n            “description”用来描述返回值的信息。\n        - `@throws`：格式如下：\n            ```java\n            @throws fully-qualified-class-name description\n            ```\n            “fully-qualified-class-name”为一个异常类的无歧义名字。对所有可能抛出的异常类都要进行说明。\n        - `@deprecated`：该标签用于指出一些旧特性已由改进的新特性取代。Java SE5中，该标签已被`@Deprecated`标签取代。\n8. 编码风格：\n    - 类名首字母要大写\n    - 如果类名由几个单词构成，那么把它们并在一起(不要用下划线来分隔名字)，其中每个内部单词的首字母都采用大写形式。这种风格有时称作“驼峰风格”。几乎其他所有内容——方法、字段(成员变量)以及对象引用名称等，都用这种格式，不一样的只是标识符的第一个字母采用小写。\n\n\n\n\n\n\n\n\n\n\n> 如果文章对你有帮助,请去我的博客留个言吧! [我的博客][1]\n\n[1]: http://an15m.tk\n","tags":["java"],"categories":["JAVA编程思想v4"]},{"title":"JAVA编程思想第四版第一章","url":"/2017/09/07/thinking-in-java-v4-1/","content":"<Excerpt in index | 首页摘要>\n第一章 对象导论\n<!-- more -->\n<The rest of contents | 余下全文>\n\n1. `private`关键字：除类型创建者和类型的内部方法之外的任何人都不能访问。  \n   `protected`关键字：与`private`相当，差别在与继承的类可以访问`protected`成员。\n\n\n\n\n\n\n\n\n> 如果文章对你有帮助,请去我的博客留个言吧! [我的博客][1]\n\n[1]: http://an15m.tk\n","tags":["java"],"categories":["java编程思想v4"]},{"title":"fsat git","url":"/2017/08/30/fsat-git/","content":"<Excerpt in index | 首页摘要>\ngit clone慢的解决方法\n<!-- more -->\n<The rest of contents | 余下全文>\n- 首先你要有一个代理，推荐[shadowsocks](https://github.com/shadowsocks)\n\n## 为http和https协议设置socks5代理\n```bash\ngit config --global http.proxy 'socks5://<your_proxy_host>:<your_proxy_port>'\ngit config --global https.proxy 'socks5://<your_proxy_host>:<your_proxy_port>'\n```\n\n## 为git协议设置socks5代理\n\n以下格式使用的是`git`协议\n```bash\ngit clone git://github.com/git/git.git\n```\n\n首先创建一个文件`git-proxy`，写入以下内容：\n```bash\n#!/bin/bash\nnc -x <your_proxy_host>:<your_proxy_port> $1 $2\n```\n这里的`nc`是`netcat openbsd`而不是`netcat traditional`。\n给文件添加可执行权限`sudo chmod +x git-proxy`。\n\n将`git-proxy`文件所在文件夹加入环境变量`$PATH`（记得刷新环境变量）。\n\n配置`core.gitProxy`：\n```bash\ngit config --global --add core.gitProxy git-proxy\n```\n\n## 为ssh协议设置socck5代理\n\n以下格式使用的是`ssh`协议：\n```bash\ngit clone git@github.com:git/git.git\n```\n\n在配置之前首先运行以下命令确保你能`ssh`到你想连接的网站。例如`github`：\n```bash\nssh -vT git@github.com\n```\n出现以下回应说明成功：\n```nohighlight\nHi your_username! You've successfully authenticated, but GitHub does not provide shell access.\n```\n\n以下方法不一定每个人都能用，取决于你的代理服务商有没有提供相关功能：\n修改 `~/.ssh/config` 加入如下内容：\n全局代理：\n```bash\nProxyCommand nc -X 5 -x <your_proxy_host>:<your_proxy_port> %h %p\n```\n特定域名进行代理：\n```bash\nHost 域名\nProxyCommand nc -X 5 -x <your_proxy_host>:<your_proxy_port> %h %p\n\nHost github.com\nProxyCommand nc -X 5 -x <your_proxy_host>:<your_proxy_port> %h %p\n```\n如果`git clone git@github:git/git.git`长时间无反应，最后报以下错误：\n```nohighlight\nssh_exchange_identification: Connection closed by remote host\nfatal: Could not read from remote repository.\n\nPlease make sure you have the correct access rights\nand the repository exists.\n```\n说明代理服务商不支持相关功能。\n\n\n\n\n\n\n\n\n\n\n\n> 如果文章对你有帮助,请去我的博客留个言吧! [我的博客][1]\n\n[1]: http://an15m.tk\n","tags":["git"],"categories":["git"]},{"title":"git config命令","url":"/2017/08/30/git-config/","content":"<Excerpt in index | 首页摘要>\ngit config命令相关知识\n<!-- more -->\n<The rest of contents | 余下全文>\n\n## 配置目录\n### git配置目录分三级\n- 仓库级，通过`--local`配置，在当前仓库下`.git/config`\n- 全局级，通过`--global`配置，在用户目录下`~/.gitconfig`\n- 系统级，通过`--system`配置，在`/etc/gitconfig`中\n- 配置文件的权重是`仓库>全局>系统`\n\n## 一些配置详解\n- `core.gitProxy`：当使用Git协议抓取时（作为命令主机端口？）执行的“代理命令”，而不是直接建立连接。如果变量值使用“COMMAND FOR DOMAIN”的格式，则该命令仅适用于以指定的域字符串结尾的主机名。该变量可以多次设置，并按照给定的顺序进行匹配; 以第一次匹配到的为准。\n这个配置可以被`GIT_PROXY_COMMAND`环境变量覆盖（它始终普遍应用）。\n特殊字符串`none`可以用作代理命令来指定给定域模式不使用任何代理。 这有助于在为外部域使用通用代理的同时从代理使用中排除防火墙内的服务器。\n- `http.sslVerify `：是否在获取或推送HTTPS时验证SSL证书。 可以被`GIT_SSL_NO_VERIY`环境变量覆盖。\n- `http.sslCert`：获取或推送HTTPS时包含SSL证书的文件。 可以被`GIT_SSL_CERT`环境变量覆盖。\n- `http.sslKey`：获取或推送HTTPS时包含SSL私钥的文件。 可以被`GIT_SSL_KEY`环境变量覆盖。\n\n\n\n\n> 如果文章对你有帮助,请去我的博客留个言吧! [我的博客][1]\n\n[1]: http://an15m.tk\n","tags":["git"],"categories":["git"]}]